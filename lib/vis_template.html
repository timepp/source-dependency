<!DOCTYPE html>
<html lang="en">

<head>
  <title>Vis Network | Other | Clustering by Zoom Level</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis-network.min.js"
    integrity="sha512-GE9mKnPrTn2DY5AZuIC9yE6K4FF8T+9lsO7jwHn+RW9rEjnHzF/in0oGwlPzRwjhQ+oJiawmtfvleX+l6h5/cA=="
    crossorigin="anonymous"></script>

  <style type="text/css">
    html,
    body {
      height: 100%
    }

    #mynetwork {
      width: 100%;
      height: 95%;
      border: 1px solid lightgray;
    }

    p {
      max-width: 600px;
    }

    h4 {
      margin-bottom: 3px;
    }
  </style>
</head>

<body>
  <div id="progress">

  </div>
  <div id="description"> 
    CTRL + mouse click = expand cluster <br>
    SHIFT + mouse click = collapse same level nodes to a new cluster
  </div>
  <div id="mynetwork"></div>

  <script type="text/javascript">
    var clusterIndex = 0;
    var clusters = [];
    var lastClusterZoomLevel = 0;
    var clusterFactor = 0.9;

    try {
      // create an array with nodes
      // [{id:string, label:string}]
      var nodes = __NODES;

      // create an array with edges
      // [{from:string, to:string}]
      var edges = __EDGES;
    }
    catch (e) {
      // sample data for test
      const sample_data = `
        a -> *external*/x/y, b -> *external*/x/z, c -> *external*/vvv, a -> h/i/j, h/x -> h/i/k, a -> b, h/x -> h/l/u, a -> h/x, h/i/j -> c,
        h/x -> *external*/yyy, h/i/j -> h/l/u
      `
      var nodes = [... new Set(sample_data.split(/,|->/g).map(v => v.trim()))].map(v => { return {id: v, label: v}})
      var edges = sample_data.split(/,/g).map(v => {
        const arr = v.split('->')
        return {
          from: arr[0].trim(),
          to: arr[1].trim()
        }
      })
    }

    nodes = nodes.map(v => {
      const r = { ...v, depth: v.id.split('/').length, folder: v.id.split('/').slice(0, -1).join('/') }
      if (v.id.startsWith('*external*')) {
        r.color = { background: '#CCCCCC' }
      }
      return r
    })
    edges = edges.map(e => {
      if (e.to.startsWith('*external*')) {
        return { ...e, color: { color: '#CCCCCC' } }
      } else {
        return e
      }
    })

    // create a network
    var container = document.getElementById("mynetwork");
    var data = {
      nodes: nodes,
      edges: edges,
    };

    var options = {
      layout: {
        randomSeed: undefined,
        improvedLayout: false,
        hierarchical: {
          enabled: false,
          levelSeparation: 150,
          nodeSpacing: 300,
          treeSpacing: 200,
          blockShifting: true,
          edgeMinimization: true,
          parentCentralization: true,
          direction: 'UD',        // UD, DU, LR, RL
          sortMethod: 'directed',  // hubsize, directed
        }
      }
    };

    var network = new vis.Network(container, data, {});
    network.setOptions({
      edges: {
        arrows: 'to',
        shadow: true,
        smooth: true,
        color: {
          color: '#303030',
          highlight: '#1010FF'
        }
      },
      nodes: {
        shape: 'box',
        shadow: true
      },
      interaction: {
        keyboard: true
      }
    })

    function createClusterProp(folder, depth) {
      return {
              color: {
                background: '#CCCCFF',
                border: '#80FF80'
              },
              id: folder,
              label: folder,
              shape: 'box',
              allowSingleNodeCluster: true,
              depth: depth,
              folder: folder.split('/').slice(0, -1).join('/')
      }
    }

    makeClusters()

    // if we click on a node, we want to open it up!
    network.on("click", function (params) {
      if (params.nodes.length == 1) {
        const shiftDown = params.event.srcEvent.shiftKey
        const ctrlDown = params.event.srcEvent.ctrlKey
        const node = params.nodes[0]
        if (shiftDown) {
          // cluster all nodes with same level
          const folder = node.split('/').slice(0, -1).join('/')
          network.cluster({
            joinCondition: function (nodeOptions) {
              const inFolder = nodeOptions.id.startsWith(folder + '/')
              if (inFolder) {
                const path = network.clustering.findNode(nodeOptions.id)
                // check if the node is already in cluster
                if (path.length === 1) {
                  console.log(`folder: ${folder}, node: ${nodeOptions.id}, join: true`)
                  return true
                }
              }
              return false
            },
            clusterNodeProperties: createClusterProp(folder)
          })
        } else if (ctrlDown) {
          if (network.isCluster(node)) {
            network.openCluster(node);
          }
        }
      }
    })

    network.on('stabilizationProgress', function (params) {
      document.getElementById('progress').innerText = `stabilizing: ${params.iterations} / ${params.total}`
    })
    network.on('stabilized', function (params) {
      document.getElementById('progress').innerText = `stabilized (took ${params.iterations} iterations)`
    })

    var canvas = container.getElementsByTagName('canvas')[0]
    var keys = vis.keycharm({container:document.body, preventDefault: false})
    keys.bind('delete', function(){
      console.log('delete')
      network.deleteSelected()
    })

    function makeClusters() {
      let maxdepth = 0
      for (const n of nodes) {
        if (maxdepth < n.depth) maxdepth = n.depth
      }
      makeClustersByDepth(0, maxdepth)
    }

    function makeClustersByDepth(depth, maxdepth) {
      if (depth < maxdepth) {
        makeClustersByDepth(depth + 1, maxdepth)
      }

      const subnodes = {}
      for (const n of nodes) {
        if (n.depth === depth) {
          subnodes[n.id] = n
        }
      }


      while (true) {
        const keys = Object.keys(subnodes)
        if (keys.length === 0) break

        const refNode = subnodes[keys[0]]
        const folder = refNode.folder
        network.cluster({
          joinCondition: function (nodeOptions) {
            if (nodeOptions.depth === refNode.depth && nodeOptions.folder === refNode.folder) {
              delete subnodes[nodeOptions.id]
              console.log(`folder: ${folder}, node: ${nodeOptions.id}, join: true`)
              return true
            }
            return false
          },
          clusterNodeProperties: createClusterProp(folder, depth - 1)
        })
      }
    }

  </script>
</body>

</html>